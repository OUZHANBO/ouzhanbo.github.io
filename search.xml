<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-01-21-redis为什么要自己实现SDS</title>
    <url>/2020/01/21/2020-01-21-Why-did-redis-implement-SDS-by-itself%20copy/</url>
    <content><![CDATA[<h3 id="Redis-为什么要自己实现一个-SDS？"><a href="#Redis-为什么要自己实现一个-SDS？" class="headerlink" title="Redis 为什么要自己实现一个 SDS？"></a>Redis 为什么要自己实现一个 SDS？</h3><h4 id="原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快"><a href="#原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快" class="headerlink" title="原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快"></a>原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快</h4><p>用 C 的字符数组实现的字符串在获取字符串长度时需要遍历整个字符数组，然后把每个字符进行计数，直到遇到空字符（<code>&#39;\0&#39;</code> ） 才停止计数得出字符串的长度，这样的时间复杂度为 <code>O(N)</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/486a41e3-fc8c-51b1-8012-673b9b65bed0.png" alt="图片丢失"></p>
<p>而 SDS 在 <code>len</code> 属性中记录了字符串的长度，所以获取字符串的长度就相当于获取 <code>len</code> 的值，时间复杂度为 <code>O(1)</code></p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//17e4cc89-1869-5162-a86d-a4521526be76.png" alt="图片丢失"></p>
<h4 id="原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出"><a href="#原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出" class="headerlink" title="原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出"></a>原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出</h4><p><code>string.h</code> 库的 <code>strcat</code> 函数将 <code>src</code> 字符串中的类容拼接到 <code>dest</code> 字符串的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为用 C 语言的字符数组实现的字符串不记录自身的长度，所以假定用户在执行 <code>strcat</code> 函数时，已经为 <code>dest</code> 分配足够多的内存空间，则可以容纳 <code>src</code> 字符串的所有内容，而一旦这个假设不成立，就会产生内存溢出</p>
<p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code> ， 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//6b53d401-6a33-5d9d-b3c3-d9fc2cf11344.png" alt="图片丢失"></p>
<p>在这种情况下如果执行如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>s1</code> 后面追加 <code>&quot; Cluster&quot;</code> ，但是<code>s1</code>的原有的空间不足，也未为 <code>s1</code> 重新分配足够的空间导致在执行 <code>strcat</code> 函数后 <code>s1</code> 的数据直接溢出到 <code>s2</code> 所在的内存空间中，最终导致 <code>s2</code> 的内容意外地被篡改，结果如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//fbd60a7d-1cd6-5380-8dda-765e517d2875.png" alt="图片丢失"></p>
<p>而 SDS 和 C 语言实现的字符串不同，SDS API 对 SDS 进行修改时 API 会先检查 SDS 的空间是不是满足修改所需的要求，如果不满足，API 会自动将 SDS 的空间扩展到执行修改所需要的空间大小，然后再执行修改操作，所以使用 SDS 不需要手动修改 SDS 的空间大小也不会出现和 C 语言字符串那样的缓冲区溢出的问题</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 <code>sdscat</code> 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， <code>sdscat</code> 会先检查给定 SDS 的空间是否足够， 如果不够的话， <code>sdscat</code> 就会先扩展 SDS 的空间， 然后才执行拼接操作</p>
<p>比如说， 如果我们执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s, <span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>SDS 的 <code>s</code> 的结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt="图片丢失"></p>
<p><code>sdscat</code>在执行拼接操作前会检查 <code>s</code> 的内存空间长度是否足够拼接 <code>&quot; Cluster&quot;</code> ，在发现 <code>s</code> 的空间长度不足够拼接 <code>&quot; Cluster&quot;</code> 后，会先扩展 <code>s</code> 的内存空间，然后再执行拼接操作，拼接后的 <code>s</code> 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt="图片丢失"></p>
<p>并且 <code>sdscat</code> 这个函数不仅对这个 SDS 进行了拼接操作，还对 SDS 分配了 13 字节的未使用空间，并且拼接之后的字符串也正好是 13 个字节，这种现象和 SDS 的空间分配策略有关</p>
<h4 id="原因三：减少修改字符串时带来的内存重新分配次数"><a href="#原因三：减少修改字符串时带来的内存重新分配次数" class="headerlink" title="原因三：减少修改字符串时带来的内存重新分配次数"></a>原因三：减少修改字符串时带来的内存重新分配次数</h4><p>因为用 C 语言实现的字符串不记录自身的长度，所以对于一个包含 N 个字符的 C 语言字符串来说，这个 C 语言字符串的底层实现总是一个 N+1 长度的字符数组 （额外的一个字符用于保存空字符 <code>&#39;\0&#39;</code>)，因为 C 字符串和底层字符数组的这种关联性，所以每次缩短和增加字符串 C 语言实现的字符串时需要对实现 C 语言字符串的底层字符数组重新进行一次内存分配</p>
<ul>
<li><p>如果程序执行的是增长字符串的操作，那么在执行该操作之前需要先重新进行一次内存分配来扩展底层的字符数组，如果忘了会导致缓冲区溢出</p>
</li>
<li><p>如果程序执行的是缩短字符串的操作，那么在执行该操作之后需要重新进行一次内存分配释放那些不再使用的那部分空间，如果忘了会导致内存泄漏</p>
</li>
</ul>
<p>举个例子，如果要将一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串 s 改为 <code>&quot;Redis Cluster&quot;</code>，在执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之前，我们需要先使用内存分配操作，扩展 s 空间</p>
<p>因为内存重新分配算法涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重新分配是可以接受的，但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重新分配的话，那么光是执行的内存重新分配的时间就占去修改字符串所有时间的一部分，如果这种修改频繁的发生的话，可能会影响性能，所以 Redis 为了避免 C 字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中，buf 数组的长度不一定是字符数量加一，数组中包含了未使用的字节，而这些未使用字节的数量就由 SDS 的 <code>free</code> 属性记录</p>
<p>通过未使用空间 SDS 实现了空间预分配和惰性空间释放着两个优化策略</p>
<h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 API 需要对 SDS 进行修改并且这个修改需要扩展 SDS 的空间的时候，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间</p>
<p>分配额外空间会根 z 据不同的的情况选择不同的策略，分配策略如下：</p>
<ul>
<li><p>如果对 SDS 进行修改之后，SDS 中 <code>len</code> 属性的值小于 <code>1</code> MB，这时程序会为 SDS 分配和 <code>len</code> 属性值一样大小的未使用空间，这时 <code>len</code> 的值和 <code>free</code> 的值是一样的，举个例子，SDS 进行扩展后， SDS 的 <code>len</code> 属性值为 <code>13</code> ，那么程序会为 SDS 分配和 <code>len</code> 属性值一样大小的 <code>13</code> 个字节的未使用空间 ，最终 <code>free</code> 的值为 <code>13</code> ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>27</code> byte(13+13+1=27,额外的自字节用于保存空字符)</p>
</li>
<li><p>如果对 SDS 进行修改之后，SDS 的 <code>len</code> 属性的值大于等于 <code>1</code> MB，这是程序会为 SDS 分配 <code>1</code> MB 的未使用空间，举个例子，SDS 进行修改后，SDS 的 <code>len</code> 的值为<code>30</code>MB，那么程序会为 SDS 分配<code>1</code> MB 的未使用空间，最终 <code>free</code> 的值为 <code>1</code> MB ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>30</code>MB + <code>1</code> MB + <code>1</code> byte</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在执行 <code>sdscat</code> 进行拼接之前需要检查 <code>s</code> 的长度是否足够，发现 <code>s</code> 的长度不够拼接 <code>&quot; Cluster&quot;</code>，<code>sdscat</code> 就会先扩展 <code>s</code> 的空间，然后才执行拼接 <code>&quot; Cluster&quot;</code>的操作</p>
<p>拼接前的 SDS 结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt="图片丢失"></p>
<p>拼接后的 SDS 的结构如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt="图片丢失"></p>
<p>如果这时在对 <code>s</code> 进行如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Tutorial&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么这次 <code>sdscat</code> 执行的时候 就不需要重新分配内存，因为未使用空间里面的 <code>13</code> 个字节可以保存 <code>9</code> 个字节的 <code>&quot; Tutorial&quot;</code> ,函数执行完后的 SDS 的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/600c714b-f1aa-51e7-b3e2-41c9bebbd790.png" alt="图片丢失"></p>
<p>在扩展 SDS 前会先检查 SDS 的 未使用空间是否已经足够扩展所需要的空间，如果未使用空间足够就直接使用未使用空间，而无需执行内存重新分配的操作，通过这种分配策略，SDS 将连续增长 N 次字符串所需的内存重新分配次数必定为 N 次减低为最多为 N 次</p>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重新分配来回收缩减多出来字节，而是使用 <code>free</code> 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>举个例子，<code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符串</p>
<p>如下面对 SDS 值 s 执行 <code>sdstrim</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdstrim(s,<span class="string">&quot;XY&quot;</span>); <span class="comment">// 移除 SDS 字符串中的所有 &#x27;X&#x27; 和 &#x27;Y&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行字符串缩减前的 SDS 如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/63d24217-4e56-4f58-a7c0-ff90a4b2e73a.png" alt="图片丢失"></p>
<p>执行 <code>sdstrim</code> 对 SDS 值 <code>s</code> 进行缩减后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/636d5b62-c44f-5c9a-a5f4-b4d32befb844.png" alt="图片丢失"></p>
<p>注意执行 <code>sdstrim</code> 之后的 SDS 并没有释放多出来的 <code>8</code> 个字节的空间，而是将这 <code>8</code> 个字节空间作为未使用的空间保留在 SDS 中，如果将要对 SDS 进行增长操作的话，这些未使用空间就可能派上用场</p>
<p>举个例子，对上面执行完 <code>sdstrim</code> 操作后的 <code>s</code> 执行 <code>sdscat</code> 操作增长操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Redis&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么完成这次 <code>sdscat</code> 操作将不需要执行内存分配因为 SDS 里面预留的 <code>8</code> 个字节的空间已经足以拼接 <code>6</code> 个字节的 <code>&quot; Redis&quot;</code> ，拼接后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/2809aa3e-8279-571c-b030-8c75e1e77f2d.png" alt="图片丢失"></p>
<p>通过惰性空间分配释放策略，SDS 避免了缩短字符串是所需要的内存重新分配操作，并且将来可能为增长操作提供优化</p>
<p>与此同时，SDS 也提供了相应的 API ,让我们可以在需要的时候，真正的释放 SDS 里面的未使用空间，所以不需要担心惰性空间策略造成的内存浪费</p>
<h4 id="原因四：二进制安全"><a href="#原因四：二进制安全" class="headerlink" title="原因四：二进制安全"></a>原因四：二进制安全</h4><p>C 语言字符串中的字符必须符合某种编码（比如 ASCII）,并且出了字符串的末尾之外，字符串的其他地方不能包含空字符（<code>&#39;\0&#39;</code> ），否者最先被程序读入的空字符串会被误认为字符串的结尾，这样导致了 C 语言字符串自能保存文本，不能保存图片、音频、视频、压缩文件这样的二进制数据</p>
<p>举个例子，如果有一个使用空字符分割多个单词的特殊数据格式，结构如下图，那么这种格式就不适合用 C 字符串保存，因为 C 字符串的函数只能识别出空字符（<code>&#39;\0&#39;</code> ）前面的 <code>Redis</code> 而它后面的 <code>&quot;Cluster&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/4f7dab93-d3df-5066-b3c7-0d7779acaa4d.png" alt="图片丢失"></p>
<p>虽然数据库一般保存的是文本数据，但是使用数据库保存二进制数据的场景也不少见，因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的：所有的 SDS API 都会处理二进制的方式处理 SDS 存在 <code>buf</code> 数组中的数据，数据写入的时候是上面样的，它读出来就是上面样的</p>
<p>这就是我们为什么将 SDS 的 <code>buf</code> 属性称为字节数组的原因，因为 Redis 不用这个数组保存字符，而是用来保存一系列的二进制数据</p>
<p>所以使用 SDS 保存上面提到的特殊格式的字符串是没有任何问题，因为 SDS 时使用 <code>len</code> 属性来判断字符串是否结束的，如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/24d91093-b1f8-551e-8c3d-771d65061f87.png" alt="图片丢失"></p>
<p>通过使用二进制安全的 SDS ，而不是 C 字符串，使得 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<h4 id="原因五：兼容部分-C-语言字符串函数"><a href="#原因五：兼容部分-C-语言字符串函数" class="headerlink" title="原因五：兼容部分 C 语言字符串函数"></a>原因五：兼容部分 C 语言字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的，但是还是遵循 C 字符串以空字符为结尾的惯例，这些 API 总是将 SDS 保存的数据的尾部设置为空字符，并且总会为 <code>buf</code> 数组分配一个额外的字节空间容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分的 <code>&lt;string.h&gt;</code> 库定义的函数</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/5c7f5e8b-0a9e-5f63-8236-1b39eddd9caf.png" alt="图片丢失"></p>
<p>举个例子，如上图所示，如果我们有一个保存文本数据的 SDS 值的 <code>sds</code>，那么我们有可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数，使用它来对比 SDS 保存字符串和另一个 C 字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf,<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就是不用专门编写一个用来对比 SDS 值和 C 字符串值的函数</p>
<p>类似的我们可以将一个保存了数据的 SDS 作为 <code>strcat</code> 函数的第二个参数，将 SDS 保存的字符串追加到一个 C 字符串的后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(c_string,sds-&gt;buf);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就不用专门去写一个函数来将 SDS 保存的字符串追加到 C 字符串后面</p>
<p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 `` 函数库， 从而避免了不必要的代码重复</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C 语言字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度的时间复杂度为 <code>O(N)</code></td>
<td style="text-align:center">获取字符串长度的复杂度为<code>O(1)</code></td>
</tr>
<tr>
<td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度 N 次必然需要执行 N 次内存重新分配</td>
<td style="text-align:center">修改字符串 N 次最多需要执行 N 次内存重新分配</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据</td>
<td style="text-align:center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:center">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数</td>
<td style="text-align:center">可使用部分 <code>&lt;stringh</code> 库中的部分函数</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-01-21-Redis 字典 dict 要定义两个哈希表的原因</title>
    <url>/2020/01/21/Redis%20%E5%AD%97%E5%85%B8%20dict%20%E8%A6%81%E5%AE%9A%E4%B9%89%E4%B8%A4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h3 id="Redis-字典-dict-要定义两个哈希表的原因"><a href="#Redis-字典-dict-要定义两个哈希表的原因" class="headerlink" title="Redis 字典 dict 要定义两个哈希表的原因"></a>Redis 字典 dict 要定义两个哈希表的原因</h3><p>Redis 字典 dict 定义两个哈希表是为了给哈希表进行扩展或者收缩准备的</p>
<h3 id="为什么-Redis-字典-dict-中的哈希表要扩展或者收缩"><a href="#为什么-Redis-字典-dict-中的哈希表要扩展或者收缩" class="headerlink" title="为什么 Redis 字典 dict 中的哈希表要扩展或者收缩"></a>为什么 Redis 字典 dict 中的哈希表要扩展或者收缩</h3><p>因为随着操作的不断执行，哈希表保存的键值对的逐渐增加或者减少，为了让哈希表负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对过多或者过少时，程序需要对哈希表的大小执行相应的扩展或者收缩</p>
<h3 id="Redis-字典-dict-如何实现哈希表的扩展和收缩"><a href="#Redis-字典-dict-如何实现哈希表的扩展和收缩" class="headerlink" title="Redis 字典 dict 如何实现哈希表的扩展和收缩"></a>Redis 字典 dict 如何实现哈希表的扩展和收缩</h3><p>扩张和收缩哈希表的工作是通过执行 rehash （重新散列）操作来完成，Redis 对字典 dict 的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作是扩展还是收缩决，以及 ht[0] 包含键值对的数量 （ht[0].used 的值）：<ul>
<li>如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2 ^ n （2 的 n 次方幂）</li>
<li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2 ^ n</li>
</ul>
</li>
<li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表中索引值对应位置上</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建一个空白哈希表，为下一次 rehash 做准备</li>
</ol>
<a id="more"></a>
<p>举个例子，假设程序要对下图所示的字典的 ht[0] 进行扩展操作，那么程序执行以下步骤：</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/1abf039c-703b-5fde-b67f-c97fe9e3273b.png" alt="图片丢失"></p>
<ol>
<li><p>ht[0].used 当前的值为 4， 4 * 2 = 8 ，而 8 （2 ^ 3） 恰好是第一个大于等于 8 的 2 的 n 次方，所以程序会将 ht[1] 哈希表的大小设置为 8，下图是为 ht[1] 在分配空间之后字典的样子</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/5fbf2db9-21a4-50b7-9dbd-3f78db2da4de.png" alt="图片丢失"></p>
</li>
<li><p>将保存在 ht[0] 包含的四个键值对都 rehash 到 ht[1]，如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/31ed5ffe-6b5e-5d6d-bfbb-53899e9c5ad9.png" alt="图片丢失"></p>
</li>
<li><p>释放 ht[0]，并将 ht[1] 设置为 ht[0]，然后为 ht[1] 分配一个空白的哈希表，如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/cb035281-bd11-5778-96e9-c3699b427ea2.png" alt="图片丢失"></p>
</li>
</ol>
<p>到此，对哈希表的扩张操作执行完毕，程序成功将哈希表的大小从原来的 4 扩展为 8</p>
<h3 id="哈希表扩展和收缩的触发条件"><a href="#哈希表扩展和收缩的触发条件" class="headerlink" title="哈希表扩展和收缩的触发条件"></a>哈希表扩展和收缩的触发条件</h3><h4 id="哈希表扩展"><a href="#哈希表扩展" class="headerlink" title="哈希表扩展"></a>哈希表扩展</h4><p>当以下条件中的任意一个被满足时，程序和自动开始对哈希表执行扩展</p>
<ol>
<li>服务器目前没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1；</li>
<li>服务器目前正在执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5；</li>
</ol>
<h4 id="哈希表的收缩"><a href="#哈希表的收缩" class="headerlink" title="哈希表的收缩"></a>哈希表的收缩</h4><p>当哈希表的负载因子小于 0.1 时，程序会自动开始对哈希表进行收缩</p>
<p>哈希表的负载因子的计算公式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<p>根据 BGSAVE 命令或者 BGREWRITEAOF 命令是否正在执行，服务器执行执行操作所需的负载因子并不相同，这是因为正在执行 BGSAVE 或者 BGREWRITEAOF 命令的过程中，Redis 需要创建当前服务进程的子进程，而大多数操作系统都采用写时复制技术来优化进程的使用效率，所以子进程存在的期间，服务器会提高执行扩展操作所需要的负载因子，从而尽量地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>好烦</title>
    <url>/2019/12/05/test/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分类1</category>
        <category>分类4</category>
        <category>分类2</category>
        <category>分类3</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-01-21-关键字声明的变量的加载问题</title>
    <url>/2020/01/21/static%20%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="static-关键字声明的变量的加载机制"><a href="#static-关键字声明的变量的加载机制" class="headerlink" title="static 关键字声明的变量的加载机制"></a>static 关键字声明的变量的加载机制</h3><p>前段时间在学习单例模式的时候遇到一种写法事用静态内部类来实现的，发现自己不是很懂静态内部类的加载时序，后来衍生到了 static 关键字修饰的变量方法都不是很懂，在网上找了一些文章看了下，大概明白他们的加载的机制和时序，下面来说下。之前我知道类的静态变量会在类被加载的时候初始化，但是类什么时候会被加载呢，这个我之前都没有考虑过。以下是我觉得我平时用得比较多的类加载方式：</p>
<p>​ 1.调用类的静态变量或者静态方法</p>
<p>​ 2.new 一个类的对象</p>
<p>​ 3.Class.forName 动态加载类</p>
<p>下面用代码测试一下第一种情况，在 Main 这个运行类型中的 main 入口方法中调用 Example 类的静态方法 staticField4，这样就会加载 Example 类并且先初始化这个类中的静态变量，静态代码块和静态代码的运行顺序取决于代码的编写顺序，然后再执行 main 方法，测试代码如下：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticField</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StaticField staticField3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法staticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Example.staticMethod1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">静态方法staticMethod1被执行</span><br></pre></td></tr></table></figure>
<p>从结果可以看出这个是先执行静态变量的初始化然后才执行静态方法，静态变量的初始化执行顺序取决代码的顺序并且静态代码块中需要初始化的静态变量可以写在静态代码块之后并且该静态变量可以声明为 final，但是不可以在静态代码块中对 final 声明的静态变量初始化两次，这样编译不会通过，实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">ExampleParent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">        <span class="comment">//编译会不通过，说staticField3已经被赋值</span></span><br><span class="line">        <span class="comment">//staticField3 = new StaticField(&quot;静态代码块中静态变量staticField3被初始化&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StaticField staticField3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里可能还有一个问题，如果在 main 中不调用 Example 的静态方法而是直接调用其中一个静态变量就只会初始化那个被调用的静态变量呢，下面修改 Main 的 main 方法来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Example.staticField2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>可以看到初始化静态变量的动作并没有发生任何的改变，还是和之前一样按顺序的将所有的静态变量初始化了。另外两种情况就在这里简单演示一下，结果都基本一样</p>
<p>第二种情况，new Example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Example();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br></pre></td></tr></table></figure>
<p>第三种情况，Class.forName 动态加载类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;Example&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br></pre></td></tr></table></figure>
<p>有一种很迷惑我的情况是不可以的，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Example.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br></pre></td></tr></table></figure>
<p>这种情况并没有加载 Example 类，这个很迷惑人，需要注意。</p>
<h3 id="父子类-static-关键字修饰的变量的加载顺序"><a href="#父子类-static-关键字修饰的变量的加载顺序" class="headerlink" title="父子类 static 关键字修饰的变量的加载顺序"></a>父子类 static 关键字修饰的变量的加载顺序</h3><p>如果出现集成的情况，那么会先执行父类的静态代内容（静态变量和静态代码块），然后再执行子类的静态内容（静态变量和静态代码块）</p>
<p>认证代码如下：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticField</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParentExample：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  StaticField parentStaticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;父类的静态变量parentStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField parentStaticField2;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            parentStaticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;父类的静态代码块中静态变量parentStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">ExampleParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法staticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Example.staticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>因为在加载 Example 这个子类之前先加载了 ParentExample 这个父类，所以感觉通过子类可以获取父类的静态成员（静态变量和静态方法）。</p>
<p>认证代码如下：</p>
<p>给父类 ParentExaple 加个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  StaticField parentStaticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;父类的静态变量parentStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField parentStaticField2;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        parentStaticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;父类的静态代码块中静态变量parentStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">parentStaticMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的静态方法parentStaticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用父类的静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Example.parentStaticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>调用父类的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Example.parentStaticField3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">父类的静态方法parentStaticMethod1被执行</span><br></pre></td></tr></table></figure>
<p>从结果发现子类可以调用父类的静态成员（静态变量或者静态方法），但是如果只是通过子类调用父类的静态成员（静态变量或者静态方法）并不会加载子类，指挥加载父类。</p>
<h3 id="static-修饰的内部类的加载机制（静态内部类）"><a href="#static-修饰的内部类的加载机制（静态内部类）" class="headerlink" title="static 修饰的内部类的加载机制（静态内部类）"></a>static 修饰的内部类的加载机制（静态内部类）</h3><p>先看看下面的测试代码：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticField</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Outer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StaticField outerStaticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;外部类静态变量innserStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        StaticField outerStaticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;外部类静态变量innserStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Innser</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span>  StaticField innserStaticField1 = <span class="keyword">new</span> StaticField(<span class="string">&quot;内部类静态变量innserStaticField1被初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            StaticField innserStaticField2 = <span class="keyword">new</span> StaticField(<span class="string">&quot;内部类静态变量innserStaticField2被初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 main 方法只是调用外部类</p>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取Outer类的静态变量outerStaticField1</span></span><br><span class="line">        System.out.println(Outer.outerStaticField1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类静态变量innserStaticField1被初始化</span><br><span class="line">外部类静态变量innserStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>如果只在 main 方法中调用内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取静态内部类Innser的静态变量innserStaticField1</span></span><br><span class="line">        System.out.println(Outer.Innser.innserStaticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">内部类静态变量innserStaticField1被初始化</span><br><span class="line">内部类静态变量innserStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>可以看出只调用外部类只会初始加载外部类并不会加载静态内部类，只调用静态内部类只记载静态内部类并不会记载外部类。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-01-21-redis为什么要自己实现SDS</title>
    <url>/2020/01/21/2020-01-21-Why-did-redis-implement-SDS-by-itself%20copy/</url>
    <content><![CDATA[<h3 id="Redis-为什么要自己实现一个-SDS？"><a href="#Redis-为什么要自己实现一个-SDS？" class="headerlink" title="Redis 为什么要自己实现一个 SDS？"></a>Redis 为什么要自己实现一个 SDS？</h3><h4 id="原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快"><a href="#原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快" class="headerlink" title="原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快"></a>原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快</h4><p>用 C 的字符数组实现的字符串在获取字符串长度时需要遍历整个字符数组，然后把每个字符进行计数，直到遇到空字符（<code>&#39;\0&#39;</code> ） 才停止计数得出字符串的长度，这样的时间复杂度为 <code>O(N)</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/486a41e3-fc8c-51b1-8012-673b9b65bed0.png" alt=""></p>
<p>而 SDS 在 <code>len</code> 属性中记录了字符串的长度，所以获取字符串的长度就相当于获取 <code>len</code> 的值，时间复杂度为 <code>O(1)</code></p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//17e4cc89-1869-5162-a86d-a4521526be76.png" alt=""></p>
<h4 id="原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出"><a href="#原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出" class="headerlink" title="原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出"></a>原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出</h4><p><code>string.h</code> 库的 <code>strcat</code> 函数将 <code>src</code> 字符串中的类容拼接到 <code>dest</code> 字符串的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为用 C 语言的字符数组实现的字符串不记录自身的长度，所以假定用户在执行 <code>strcat</code> 函数时，已经为 <code>dest</code> 分配足够多的内存空间，则可以容纳 <code>src</code> 字符串的所有内容，而一旦这个假设不成立，就会产生内存溢出</p>
<p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code> ， 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//6b53d401-6a33-5d9d-b3c3-d9fc2cf11344.png" alt=""></p>
<p>在这种情况下如果执行如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>s1</code> 后面追加 <code>&quot; Cluster&quot;</code> ，但是<code>s1</code>的原有的空间不足，也未为 <code>s1</code> 重新分配足够的空间导致在执行 <code>strcat</code> 函数后 <code>s1</code> 的数据直接溢出到 <code>s2</code> 所在的内存空间中，最终导致 <code>s2</code> 的内容意外地被篡改，结果如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//fbd60a7d-1cd6-5380-8dda-765e517d2875.png" alt=""></p>
<p>而 SDS 和 C 语言实现的字符串不同，SDS API 对 SDS 进行修改时 API 会先检查 SDS 的空间是不是满足修改所需的要求，如果不满足，API 会自动将 SDS 的空间扩展到执行修改所需要的空间大小，然后再执行修改操作，所以使用 SDS 不需要手动修改 SDS 的空间大小也不会出现和 C 语言字符串那样的缓冲区溢出的问题</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 <code>sdscat</code> 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， <code>sdscat</code> 会先检查给定 SDS 的空间是否足够， 如果不够的话， <code>sdscat</code> 就会先扩展 SDS 的空间， 然后才执行拼接操作</p>
<p>比如说， 如果我们执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s, <span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>SDS 的 <code>s</code> 的结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt=""></p>
<p><code>sdscat</code>在执行拼接操作前会检查 <code>s</code> 的内存空间长度是否足够拼接 <code>&quot; Cluster&quot;</code> ，在发现 <code>s</code> 的空间长度不足够拼接 <code>&quot; Cluster&quot;</code> 后，会先扩展 <code>s</code> 的内存空间，然后再执行拼接操作，拼接后的 <code>s</code> 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt=""></p>
<p>并且 <code>sdscat</code> 这个函数不仅对这个 SDS 进行了拼接操作，还对 SDS 分配了 13 字节的未使用空间，并且拼接之后的字符串也正好是 13 个字节，这种现象和 SDS 的空间分配策略有关</p>
<h4 id="原因三：减少修改字符串时带来的内存重新分配次数"><a href="#原因三：减少修改字符串时带来的内存重新分配次数" class="headerlink" title="原因三：减少修改字符串时带来的内存重新分配次数"></a>原因三：减少修改字符串时带来的内存重新分配次数</h4><p>因为用 C 语言实现的字符串不记录自身的长度，所以对于一个包含 N 个字符的 C 语言字符串来说，这个 C 语言字符串的底层实现总是一个 N+1 长度的字符数组 （额外的一个字符用于保存空字符 <code>&#39;\0&#39;</code>)，因为 C 字符串和底层字符数组的这种关联性，所以每次缩短和增加字符串 C 语言实现的字符串时需要对实现 C 语言字符串的底层字符数组重新进行一次内存分配</p>
<ul>
<li><p>如果程序执行的是增长字符串的操作，那么在执行该操作之前需要先重新进行一次内存分配来扩展底层的字符数组，如果忘了会导致缓冲区溢出</p>
</li>
<li><p>如果程序执行的是缩短字符串的操作，那么在执行该操作之后需要重新进行一次内存分配释放那些不再使用的那部分空间，如果忘了会导致内存泄漏</p>
</li>
</ul>
<p>举个例子，如果要将一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串 s 改为 <code>&quot;Redis Cluster&quot;</code>，在执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之前，我们需要先使用内存分配操作，扩展 s 空间</p>
<p>因为内存重新分配算法涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重新分配是可以接受的，但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重新分配的话，那么光是执行的内存重新分配的时间就占去修改字符串所有时间的一部分，如果这种修改频繁的发生的话，可能会影响性能，所以 Redis 为了避免 C 字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中，buf 数组的长度不一定是字符数量加一，数组中包含了未使用的字节，而这些未使用字节的数量就由 SDS 的 <code>free</code> 属性记录</p>
<p>通过未使用空间 SDS 实现了空间预分配和惰性空间释放着两个优化策略</p>
<h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 API 需要对 SDS 进行修改并且这个修改需要扩展 SDS 的空间的时候，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间</p>
<p>分配额外空间会根 z 据不同的的情况选择不同的策略，分配策略如下：</p>
<ul>
<li><p>如果对 SDS 进行修改之后，SDS 中 <code>len</code> 属性的值小于 <code>1</code> MB，这时程序会为 SDS 分配和 <code>len</code> 属性值一样大小的未使用空间，这时 <code>len</code> 的值和 <code>free</code> 的值是一样的，举个例子，SDS 进行扩展后， SDS 的 <code>len</code> 属性值为 <code>13</code> ，那么程序会为 SDS 分配和 <code>len</code> 属性值一样大小的 <code>13</code> 个字节的未使用空间 ，最终 <code>free</code> 的值为 <code>13</code> ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>27</code> byte(13+13+1=27,额外的自字节用于保存空字符)</p>
</li>
<li><p>如果对 SDS 进行修改之后，SDS 的 <code>len</code> 属性的值大于等于 <code>1</code> MB，这是程序会为 SDS 分配 <code>1</code> MB 的未使用空间，举个例子，SDS 进行修改后，SDS 的 <code>len</code> 的值为<code>30</code>MB，那么程序会为 SDS 分配<code>1</code> MB 的未使用空间，最终 <code>free</code> 的值为 <code>1</code> MB ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>30</code>MB + <code>1</code> MB + <code>1</code> byte</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在执行 <code>sdscat</code> 进行拼接之前需要检查 <code>s</code> 的长度是否足够，发现 <code>s</code> 的长度不够拼接 <code>&quot; Cluster&quot;</code>，<code>sdscat</code> 就会先扩展 <code>s</code> 的空间，然后才执行拼接 <code>&quot; Cluster&quot;</code>的操作</p>
<p>拼接前的 SDS 结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt=""></p>
<p>拼接后的 SDS 的结构如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt=""></p>
<p>如果这时在对 <code>s</code> 进行如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Tutorial&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么这次 <code>sdscat</code> 执行的时候 就不需要重新分配内存，因为未使用空间里面的 <code>13</code> 个字节可以保存 <code>9</code> 个字节的 <code>&quot; Tutorial&quot;</code> ,函数执行完后的 SDS 的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/600c714b-f1aa-51e7-b3e2-41c9bebbd790.png" alt=""></p>
<p>在扩展 SDS 前会先检查 SDS 的 未使用空间是否已经足够扩展所需要的空间，如果未使用空间足够就直接使用未使用空间，而无需执行内存重新分配的操作，通过这种分配策略，SDS 将连续增长 N 次字符串所需的内存重新分配次数必定为 N 次减低为最多为 N 次</p>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重新分配来回收缩减多出来字节，而是使用 <code>free</code> 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>举个例子，<code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符串</p>
<p>如下面对 SDS 值 s 执行 <code>sdstrim</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdstrim(s,<span class="string">&quot;XY&quot;</span>); <span class="comment">// 移除 SDS 字符串中的所有 &#x27;X&#x27; 和 &#x27;Y&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行字符串缩减前的 SDS 如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/63d24217-4e56-4f58-a7c0-ff90a4b2e73a.png" alt=""></p>
<p>执行 <code>sdstrim</code> 对 SDS 值 <code>s</code> 进行缩减后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/636d5b62-c44f-5c9a-a5f4-b4d32befb844.png" alt=""></p>
<p>注意执行 <code>sdstrim</code> 之后的 SDS 并没有释放多出来的 <code>8</code> 个字节的空间，而是将这 <code>8</code> 个字节空间作为未使用的空间保留在 SDS 中，如果将要对 SDS 进行增长操作的话，这些未使用空间就可能派上用场</p>
<p>举个例子，对上面执行完 <code>sdstrim</code> 操作后的 <code>s</code> 执行 <code>sdscat</code> 操作增长操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Redis&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么完成这次 <code>sdscat</code> 操作将不需要执行内存分配因为 SDS 里面预留的 <code>8</code> 个字节的空间已经足以拼接 <code>6</code> 个字节的 <code>&quot; Redis&quot;</code> ，拼接后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/2809aa3e-8279-571c-b030-8c75e1e77f2d.png" alt=""></p>
<p>通过惰性空间分配释放策略，SDS 避免了缩短字符串是所需要的内存重新分配操作，并且将来可能为增长操作提供优化</p>
<p>与此同时，SDS 也提供了相应的 API ,让我们可以在需要的时候，真正的释放 SDS 里面的未使用空间，所以不需要担心惰性空间策略造成的内存浪费</p>
<h4 id="原因四：二进制安全"><a href="#原因四：二进制安全" class="headerlink" title="原因四：二进制安全"></a>原因四：二进制安全</h4><p>C 语言字符串中的字符必须符合某种编码（比如 ASCII）,并且出了字符串的末尾之外，字符串的其他地方不能包含空字符（<code>&#39;\0&#39;</code> ），否者最先被程序读入的空字符串会被误认为字符串的结尾，这样导致了 C 语言字符串自能保存文本，不能保存图片、音频、视频、压缩文件这样的二进制数据</p>
<p>举个例子，如果有一个使用空字符分割多个单词的特殊数据格式，结构如下图，那么这种格式就不适合用 C 字符串保存，因为 C 字符串的函数只能识别出空字符（<code>&#39;\0&#39;</code> ）前面的 <code>Redis</code> 而它后面的 <code>&quot;Cluster&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/4f7dab93-d3df-5066-b3c7-0d7779acaa4d.png" alt=""></p>
<p>虽然数据库一般保存的是文本数据，但是使用数据库保存二进制数据的场景也不少见，因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的：所有的 SDS API 都会处理二进制的方式处理 SDS 存在 <code>buf</code> 数组中的数据，数据写入的时候是上面样的，它读出来就是上面样的</p>
<p>这就是我们为什么将 SDS 的 <code>buf</code> 属性称为字节数组的原因，因为 Redis 不用这个数组保存字符，而是用来保存一系列的二进制数据</p>
<p>所以使用 SDS 保存上面提到的特殊格式的字符串是没有任何问题，因为 SDS 时使用 <code>len</code> 属性来判断字符串是否结束的，如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/24d91093-b1f8-551e-8c3d-771d65061f87.png" alt=""></p>
<p>通过使用二进制安全的 SDS ，而不是 C 字符串，使得 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<h4 id="原因五：兼容部分-C-语言字符串函数"><a href="#原因五：兼容部分-C-语言字符串函数" class="headerlink" title="原因五：兼容部分 C 语言字符串函数"></a>原因五：兼容部分 C 语言字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的，但是还是遵循 C 字符串以空字符为结尾的惯例，这些 API 总是将 SDS 保存的数据的尾部设置为空字符，并且总会为 <code>buf</code> 数组分配一个额外的字节空间容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分的 <code>&lt;string.h&gt;</code> 库定义的函数</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/5c7f5e8b-0a9e-5f63-8236-1b39eddd9caf.png" alt=""></p>
<p>举个例子，如上图所示，如果我们有一个保存文本数据的 SDS 值的 <code>sds</code>，那么我们有可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数，使用它来对比 SDS 保存字符串和另一个 C 字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf,<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就是不用专门编写一个用来对比 SDS 值和 C 字符串值的函数</p>
<p>类似的我们可以将一个保存了数据的 SDS 作为 <code>strcat</code> 函数的第二个参数，将 SDS 保存的字符串追加到一个 C 字符串的后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(c_string,sds-&gt;buf);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就不用专门去写一个函数来将 SDS 保存的字符串追加到 C 字符串后面</p>
<p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 `` 函数库， 从而避免了不必要的代码重复</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C 语言字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度的时间复杂度为 <code>O(N)</code></td>
<td style="text-align:center">获取字符串长度的复杂度为<code>O(1)</code></td>
</tr>
<tr>
<td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度 N 次必然需要执行 N 次内存重新分配</td>
<td style="text-align:center">修改字符串 N 次最多需要执行 N 次内存重新分配</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据</td>
<td style="text-align:center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:center">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数</td>
<td style="text-align:center">可使用部分 <code>&lt;stringh</code> 库中的部分函数</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-01-21-redis为什么要自己实现SDS</title>
    <url>/2020/01/21/2020-01-21-Why-did-redis-implement-SDS-by-itself/</url>
    <content><![CDATA[<h3 id="Redis-为什么要自己实现一个-SDS？"><a href="#Redis-为什么要自己实现一个-SDS？" class="headerlink" title="Redis 为什么要自己实现一个 SDS？"></a>Redis 为什么要自己实现一个 SDS？</h3><h4 id="原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快"><a href="#原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快" class="headerlink" title="原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快"></a>原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快</h4><p>用 C 的字符数组实现的字符串在获取字符串长度时需要遍历整个字符数组，然后把每个字符进行计数，直到遇到空字符（<code>&#39;\0&#39;</code> ） 才停止计数得出字符串的长度，这样的时间复杂度为 <code>O(N)</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/486a41e3-fc8c-51b1-8012-673b9b65bed0.png" alt=""></p>
<p>而 SDS 在 <code>len</code> 属性中记录了字符串的长度，所以获取字符串的长度就相当于获取 <code>len</code> 的值，时间复杂度为 <code>O(1)</code></p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//17e4cc89-1869-5162-a86d-a4521526be76.png" alt=""></p>
<h4 id="原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出"><a href="#原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出" class="headerlink" title="原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出"></a>原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出</h4><p><code>string.h</code> 库的 <code>strcat</code> 函数将 <code>src</code> 字符串中的类容拼接到 <code>dest</code> 字符串的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为用 C 语言的字符数组实现的字符串不记录自身的长度，所以假定用户在执行 <code>strcat</code> 函数时，已经为 <code>dest</code> 分配足够多的内存空间，则可以容纳 <code>src</code> 字符串的所有内容，而一旦这个假设不成立，就会产生内存溢出</p>
<p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code> ， 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//6b53d401-6a33-5d9d-b3c3-d9fc2cf11344.png" alt=""></p>
<p>在这种情况下如果执行如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>s1</code> 后面追加 <code>&quot; Cluster&quot;</code> ，但是<code>s1</code>的原有的空间不足，也未为 <code>s1</code> 重新分配足够的空间导致在执行 <code>strcat</code> 函数后 <code>s1</code> 的数据直接溢出到 <code>s2</code> 所在的内存空间中，最终导致 <code>s2</code> 的内容意外地被篡改，结果如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//fbd60a7d-1cd6-5380-8dda-765e517d2875.png" alt=""></p>
<p>而 SDS 和 C 语言实现的字符串不同，SDS API 对 SDS 进行修改时 API 会先检查 SDS 的空间是不是满足修改所需的要求，如果不满足，API 会自动将 SDS 的空间扩展到执行修改所需要的空间大小，然后再执行修改操作，所以使用 SDS 不需要手动修改 SDS 的空间大小也不会出现和 C 语言字符串那样的缓冲区溢出的问题</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 <code>sdscat</code> 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， <code>sdscat</code> 会先检查给定 SDS 的空间是否足够， 如果不够的话， <code>sdscat</code> 就会先扩展 SDS 的空间， 然后才执行拼接操作</p>
<p>比如说， 如果我们执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s, <span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>SDS 的 <code>s</code> 的结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt=""></p>
<p><code>sdscat</code>在执行拼接操作前会检查 <code>s</code> 的内存空间长度是否足够拼接 <code>&quot; Cluster&quot;</code> ，在发现 <code>s</code> 的空间长度不足够拼接 <code>&quot; Cluster&quot;</code> 后，会先扩展 <code>s</code> 的内存空间，然后再执行拼接操作，拼接后的 <code>s</code> 如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt=""></p>
<p>并且 <code>sdscat</code> 这个函数不仅对这个 SDS 进行了拼接操作，还对 SDS 分配了 13 字节的未使用空间，并且拼接之后的字符串也正好是 13 个字节，这种现象和 SDS 的空间分配策略有关</p>
<h4 id="原因三：减少修改字符串时带来的内存重新分配次数"><a href="#原因三：减少修改字符串时带来的内存重新分配次数" class="headerlink" title="原因三：减少修改字符串时带来的内存重新分配次数"></a>原因三：减少修改字符串时带来的内存重新分配次数</h4><p>因为用 C 语言实现的字符串不记录自身的长度，所以对于一个包含 N 个字符的 C 语言字符串来说，这个 C 语言字符串的底层实现总是一个 N+1 长度的字符数组 （额外的一个字符用于保存空字符 <code>&#39;\0&#39;</code>)，因为 C 字符串和底层字符数组的这种关联性，所以每次缩短和增加字符串 C 语言实现的字符串时需要对实现 C 语言字符串的底层字符数组重新进行一次内存分配</p>
<ul>
<li><p>如果程序执行的是增长字符串的操作，那么在执行该操作之前需要先重新进行一次内存分配来扩展底层的字符数组，如果忘了会导致缓冲区溢出</p>
</li>
<li><p>如果程序执行的是缩短字符串的操作，那么在执行该操作之后需要重新进行一次内存分配释放那些不再使用的那部分空间，如果忘了会导致内存泄漏</p>
</li>
</ul>
<p>举个例子，如果要将一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串 s 改为 <code>&quot;Redis Cluster&quot;</code>，在执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之前，我们需要先使用内存分配操作，扩展 s 空间</p>
<p>因为内存重新分配算法涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重新分配是可以接受的，但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重新分配的话，那么光是执行的内存重新分配的时间就占去修改字符串所有时间的一部分，如果这种修改频繁的发生的话，可能会影响性能，所以 Redis 为了避免 C 字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中，buf 数组的长度不一定是字符数量加一，数组中包含了未使用的字节，而这些未使用字节的数量就由 SDS 的 <code>free</code> 属性记录</p>
<p>通过未使用空间 SDS 实现了空间预分配和惰性空间释放着两个优化策略</p>
<h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 API 需要对 SDS 进行修改并且这个修改需要扩展 SDS 的空间的时候，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间</p>
<p>分配额外空间会根 z 据不同的的情况选择不同的策略，分配策略如下：</p>
<ul>
<li><p>如果对 SDS 进行修改之后，SDS 中 <code>len</code> 属性的值小于 <code>1</code> MB，这时程序会为 SDS 分配和 <code>len</code> 属性值一样大小的未使用空间，这时 <code>len</code> 的值和 <code>free</code> 的值是一样的，举个例子，SDS 进行扩展后， SDS 的 <code>len</code> 属性值为 <code>13</code> ，那么程序会为 SDS 分配和 <code>len</code> 属性值一样大小的 <code>13</code> 个字节的未使用空间 ，最终 <code>free</code> 的值为 <code>13</code> ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>27</code> byte(13+13+1=27,额外的自字节用于保存空字符)</p>
</li>
<li><p>如果对 SDS 进行修改之后，SDS 的 <code>len</code> 属性的值大于等于 <code>1</code> MB，这是程序会为 SDS 分配 <code>1</code> MB 的未使用空间，举个例子，SDS 进行修改后，SDS 的 <code>len</code> 的值为<code>30</code>MB，那么程序会为 SDS 分配<code>1</code> MB 的未使用空间，最终 <code>free</code> 的值为 <code>1</code> MB ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>30</code>MB + <code>1</code> MB + <code>1</code> byte</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在执行 <code>sdscat</code> 进行拼接之前需要检查 <code>s</code> 的长度是否足够，发现 <code>s</code> 的长度不够拼接 <code>&quot; Cluster&quot;</code>，<code>sdscat</code> 就会先扩展 <code>s</code> 的空间，然后才执行拼接 <code>&quot; Cluster&quot;</code>的操作</p>
<p>拼接前的 SDS 结构如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt=""></p>
<p>拼接后的 SDS 的结构如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt=""></p>
<p>如果这时在对 <code>s</code> 进行如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Tutorial&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么这次 <code>sdscat</code> 执行的时候 就不需要重新分配内存，因为未使用空间里面的 <code>13</code> 个字节可以保存 <code>9</code> 个字节的 <code>&quot; Tutorial&quot;</code> ,函数执行完后的 SDS 的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/600c714b-f1aa-51e7-b3e2-41c9bebbd790.png" alt=""></p>
<p>在扩展 SDS 前会先检查 SDS 的 未使用空间是否已经足够扩展所需要的空间，如果未使用空间足够就直接使用未使用空间，而无需执行内存重新分配的操作，通过这种分配策略，SDS 将连续增长 N 次字符串所需的内存重新分配次数必定为 N 次减低为最多为 N 次</p>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重新分配来回收缩减多出来字节，而是使用 <code>free</code> 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>举个例子，<code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符串</p>
<p>如下面对 SDS 值 s 执行 <code>sdstrim</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdstrim(s,<span class="string">&quot;XY&quot;</span>); <span class="comment">// 移除 SDS 字符串中的所有 &#x27;X&#x27; 和 &#x27;Y&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行字符串缩减前的 SDS 如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/63d24217-4e56-4f58-a7c0-ff90a4b2e73a.png" alt=""></p>
<p>执行 <code>sdstrim</code> 对 SDS 值 <code>s</code> 进行缩减后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/636d5b62-c44f-5c9a-a5f4-b4d32befb844.png" alt=""></p>
<p>注意执行 <code>sdstrim</code> 之后的 SDS 并没有释放多出来的 <code>8</code> 个字节的空间，而是将这 <code>8</code> 个字节空间作为未使用的空间保留在 SDS 中，如果将要对 SDS 进行增长操作的话，这些未使用空间就可能派上用场</p>
<p>举个例子，对上面执行完 <code>sdstrim</code> 操作后的 <code>s</code> 执行 <code>sdscat</code> 操作增长操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Redis&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么完成这次 <code>sdscat</code> 操作将不需要执行内存分配因为 SDS 里面预留的 <code>8</code> 个字节的空间已经足以拼接 <code>6</code> 个字节的 <code>&quot; Redis&quot;</code> ，拼接后的结构图如下</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/2809aa3e-8279-571c-b030-8c75e1e77f2d.png" alt=""></p>
<p>通过惰性空间分配释放策略，SDS 避免了缩短字符串是所需要的内存重新分配操作，并且将来可能为增长操作提供优化</p>
<p>与此同时，SDS 也提供了相应的 API ,让我们可以在需要的时候，真正的释放 SDS 里面的未使用空间，所以不需要担心惰性空间策略造成的内存浪费</p>
<h4 id="原因四：二进制安全"><a href="#原因四：二进制安全" class="headerlink" title="原因四：二进制安全"></a>原因四：二进制安全</h4><p>C 语言字符串中的字符必须符合某种编码（比如 ASCII）,并且出了字符串的末尾之外，字符串的其他地方不能包含空字符（<code>&#39;\0&#39;</code> ），否者最先被程序读入的空字符串会被误认为字符串的结尾，这样导致了 C 语言字符串自能保存文本，不能保存图片、音频、视频、压缩文件这样的二进制数据</p>
<p>举个例子，如果有一个使用空字符分割多个单词的特殊数据格式，结构如下图，那么这种格式就不适合用 C 字符串保存，因为 C 字符串的函数只能识别出空字符（<code>&#39;\0&#39;</code> ）前面的 <code>Redis</code> 而它后面的 <code>&quot;Cluster&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/4f7dab93-d3df-5066-b3c7-0d7779acaa4d.png" alt=""></p>
<p>虽然数据库一般保存的是文本数据，但是使用数据库保存二进制数据的场景也不少见，因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的：所有的 SDS API 都会处理二进制的方式处理 SDS 存在 <code>buf</code> 数组中的数据，数据写入的时候是上面样的，它读出来就是上面样的</p>
<p>这就是我们为什么将 SDS 的 <code>buf</code> 属性称为字节数组的原因，因为 Redis 不用这个数组保存字符，而是用来保存一系列的二进制数据</p>
<p>所以使用 SDS 保存上面提到的特殊格式的字符串是没有任何问题，因为 SDS 时使用 <code>len</code> 属性来判断字符串是否结束的，如下图</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/24d91093-b1f8-551e-8c3d-771d65061f87.png" alt=""></p>
<p>通过使用二进制安全的 SDS ，而不是 C 字符串，使得 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<h4 id="原因五：兼容部分-C-语言字符串函数"><a href="#原因五：兼容部分-C-语言字符串函数" class="headerlink" title="原因五：兼容部分 C 语言字符串函数"></a>原因五：兼容部分 C 语言字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的，但是还是遵循 C 字符串以空字符为结尾的惯例，这些 API 总是将 SDS 保存的数据的尾部设置为空字符，并且总会为 <code>buf</code> 数组分配一个额外的字节空间容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分的 <code>&lt;string.h&gt;</code> 库定义的函数</p>
<p><img src="https://raw.githubusercontent.com/OUZHANBO/pics/master/img/5c7f5e8b-0a9e-5f63-8236-1b39eddd9caf.png" alt=""></p>
<p>举个例子，如上图所示，如果我们有一个保存文本数据的 SDS 值的 <code>sds</code>，那么我们有可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数，使用它来对比 SDS 保存字符串和另一个 C 字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf,<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就是不用专门编写一个用来对比 SDS 值和 C 字符串值的函数</p>
<p>类似的我们可以将一个保存了数据的 SDS 作为 <code>strcat</code> 函数的第二个参数，将 SDS 保存的字符串追加到一个 C 字符串的后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(c_string,sds-&gt;buf);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就不用专门去写一个函数来将 SDS 保存的字符串追加到 C 字符串后面</p>
<p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 `` 函数库， 从而避免了不必要的代码重复</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C 语言字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度的时间复杂度为 <code>O(N)</code></td>
<td style="text-align:center">获取字符串长度的复杂度为<code>O(1)</code></td>
</tr>
<tr>
<td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度 N 次必然需要执行 N 次内存重新分配</td>
<td style="text-align:center">修改字符串 N 次最多需要执行 N 次内存重新分配</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据</td>
<td style="text-align:center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:center">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数</td>
<td style="text-align:center">可使用部分 <code>&lt;stringh</code> 库中的部分函数</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>好烦</title>
    <url>/2019/12/05/test/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分类1</category>
        <category>分类4</category>
        <category>分类2</category>
        <category>分类3</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
